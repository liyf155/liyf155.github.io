[{"title":"06-Java类加载器","date":"2020-05-28T15:39:04.000Z","path":"2020/05/28/jvm/06-Java类加载器/","text":"Java类加载器当JVM（Java虚拟机）启动时，会形成由三个类加载器组成的初始类加载器层次结构： Bootstrap classloader －引导（也称为原始）类加载器引导类加载器主要负责加载Java的核心类。在Sun的JVM中，在执行java的命令中使用-Xbootclasspath选项或使用 -D选项指定sun.boot.class.path系统属性值可以指定附加的类。这个加载器的是非常特殊的，它实际上不是 java.lang.ClassLoader的子类，而是由JVM自身实现的。我们可以通过执行以下代码来获得bootstrap classloader加载了那些核心类库： 12345URL[] urls=sun.misc.Launcher.getBootstrapClassPath().getURLs();for (int i = 0; i &lt; urls.length; i++) &#123; System.out.println(urls[i].toExternalForm());&#125; 在我的计算机上的结果为： 12345678file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/resources.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/sunrsasign.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jsse.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jce.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/charsets.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jfr.jarfile:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/classes 这时大家知道了为什么我们不需要在系统属性CLASSPATH中指定这些类库了吧，因为JVM在启动的时候就自动加载它们了。 Extension classloader －扩展类加载器扩展类加载器负责加载JRE的扩展目录（JAVA_HOME/jre/lib/ext或者由java.ext.dirs系统属性指定的）中JAR的类包。这为引入除Java核心类以外的新功能提供了一个标准机制。因为默认的扩展目录对所有从同一个JRE中启动的JVM都是通用的，所以放入这个目录的 JAR类包对所有的JVM和system classloader都是可见的。在这个实例上调用方法getParent()总是返回空值null，因为引导加载器bootstrap classloader不是一个真正的ClassLoader实例。所以当大家执行以下代码时： 123System.out.println(System.getProperty(\"java.ext.dirs\"));ClassLoader extensionClassloader=ClassLoader.getSystemClassLoader().getParent(); System.out.println(\"the parent of extension classloader : \"+extensionClassloader.getParent()); 结果为： 1file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/ext the parent of extension classloader : null 扩展类加载器是system classloader的parent，而引导类加载器是扩展类加载器的parent，但它不是一个实际的classloader，所以为null。 Application classloader －应用类加载器应用类加载器负责在JVM被启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH*作系统属性所指定的JAR类包和类路径。总能通过静态方法ClassLoader.getSystemClassLoader()找到该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器。执行以下代码即可获得： 1System.out.println(System.getProperty(\"java.class.path\")); 输出结果则为用户在系统属性里面设置的CLASSPATH。应用类加载器用的是全盘负责委托机制，所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入；委托机制则是先让parent（父）类加载器 (而不是super，它与parent classloader类不是继承关系)寻找，只有在parent找不到的时候才从自己的类路径中去寻找。此外类加载还采用了cache机制，也就是如果 cache中保存了这个Class就直接返回它，如果没有才从文件中读取和转换成Class，并存入cache，这就是为什么我们修改了Class但是必须重新启动JVM才能生效的原因。 每个ClassLoader加载Class的过程是： 检测此Class是否载入过（即在cache中是否有此Class），如果有到8,如果没有到2 如果parent classloader不存在（没有parent，那parent一定是bootstrap classloader了），到4 请求parent classloader载入，如果成功到8，不成功到5 请求jvm从bootstrap classloader中载入，如果成功到8 寻找Class文件（从与此classloader相关的类路径中寻找）。如果找不到则到7. 从文件中载入Class，到8. 抛出ClassNotFoundException. 返回Class. 其中5、6步我们可以通过覆盖ClassLoader的findClass方法来实现自己的载入策略。甚至覆盖loadClass方法来实现自己的载入过程。 类加载器的顺序是：先是Bootstrap classloader，然后是Extension classloader，最后才是Application classloader。大家会发现加载的Class越是重要的越在靠前面。这样做的原因是出于安全性的考虑，试想如果Application classloader“亲自”加载了一个具有破坏性的“java.lang.System”类的后果吧。这种委托机制保证了用户即使具有一个这样的类，也把它加入到了类路径中，但是它永远不会被载入，因为这个类总是由bootstrap classloader来加载的。大家可以执行一下以下的代码： 1System.out.println(System.class.getClassLoader()); 将会看到结果是null，这就表明java.lang.System是由bootstrap classloader加载的，因为bootstrap classloader不是一个真正的ClassLoader实例，而是由JVM实现的，正如前面已经说过的。 下面就让我们来看看JVM是如何来为我们来建立类加载器的结构的：sun.misc.Launcher，顾名思义，当你执行java命令的时候，JVM会先使用bootstrap classloader载入并初始化一个Launcher，执行下来代码： 1System.out.println(\"the Launcher's classloader is \"+sun.misc.Launcher.getLauncher().getClass().getClassLoader()); 结果为： the Launcher’s classloader is null (因为是用bootstrap classloader加载,所以class loader为null)，Launcher 会根据系统和命令设定初始化好class loader结构，JVM就用它来获得extension classloader和system classloader,并载入所有的需要载入的Class，最后执行java命令指定的带有静态的main方法的Class，extension classloader实际上是sun.misc.Launcher.ExtClassLoader类的一个实例，systemclassloader实际上是sun.misc.LauncherExtClassLoader类的一个实例，并且都是 java.net.URLClassLoader的子类。","tags":[{"name":"Java类加载器","slug":"Java类加载器","permalink":"http://liyf155.github.io/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"}]},{"title":"05-Java类加载过程","date":"2020-05-28T15:21:37.000Z","path":"2020/05/28/jvm/05-Java类加载过程/","text":"Java类加载过程1. 类的加载类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区内的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Validation）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备解析3个部分统称为连接（Linking），顺序如下图所示： 1.1 加载“加载”是“类加载”过程的一个阶段，在此阶段虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据结构访问入口 相对于加载的其他阶段而言，加载阶段（准确的说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载，加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 1.2 连接连接阶段可拆分为4个：验证（Validation）、准备（Preparation）、解析（Resolution）、初始化（Initialization） 1.2.1 验证验证是连接阶段的第一步，该阶段的目的是为了确保Class文件中的字节流所包含的信息如何当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致完成4个检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型； 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，例如：这个类是否有父类； 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的； 符号引用验证：确保解析动作能正确执行； 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 1.2.2 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 123；那么变量value在准备阶段过后的初始值为0，而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 1.2.3 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 符号引用：符号引用以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可；符号引用于虚拟机实现的内存布局无关，引用的目标并不定已经加载到内存中。 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用于虚拟机实现的内存布局有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 1.2.4 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段才真正开始执行类中定义的Java程序代码。 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达。初始化主要有以下几个步骤： 如果这个类还没有被加载和连接，则程序先加载并连接该类； 如果该类的直接父类还没有被初始化，则先初始化其直接父类； 如果类中有初始化语句，则系统依次执行这些初始化语句； 类初始化时机：只有当对垒的主动使用时才会导致类的初始化，有如下几种情况： 创建类的实例，即new一个对象； 访问某个类或接口的静态变量，或者对该静态变量赋值； 调用类的静态方法； 反射，如Class.forName(); 初始化某个类的子类，则其父类也会被初始化； Java虚拟机启动时被表明为启动类的类，直接使用java.exe命令来运行某个主类； 2. 卸载卸载即表示结束该类的声明周期，分以下几种情况： 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而终止程序 由于操作系统出现错误而导致Java虚拟机进程终止","tags":[{"name":"Java类加载过程","slug":"Java类加载过程","permalink":"http://liyf155.github.io/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"}]},{"title":"04-JVM内存分配策略-逃逸分析","date":"2020-05-18T23:17:15.000Z","path":"2020/05/19/jvm/04-JVM内存分配策略-逃逸分析/","text":"JVM内存分配策略-逃逸分析通过前面章节的学习，应该已经掌握了以下几个知识点： Java虚拟机所管理的内存包括方法区、虚拟机栈、本地方法栈、堆、程序计数器 栈中存放一些基本类型的变量数据（int/short/long/byte/float/double/Boolean/char）和对象引用 堆中主要存放对象，即通过new关键字创建的对象 数组引用变量是存放在栈内存中，数组元素是存放在堆内存中 对象分配流程如下图所示： 在《深入理解Java虚拟机》一书中，有说过这样一句话： 但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 也就是说，在编译期间，JIT会对代码做很多优化，其目的就是减少内存堆分配的压力，其中有一种技术叫做逃逸分析。 什么是逃逸分析逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。 使用逃逸分析，编译器可以对代码做如下优化： 一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。 三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。 在Java代码运行时，通过JVM参数可指定是否开启逃逸分析， -XX:+DoEscapeAnalysis ： 表示开启逃逸分析 -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis 对象的栈上内存分配在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。JIT编译器就可以在编译期间根据逃逸分析的结果，来决定是否可以将对象的内存分配从堆转化为栈。 代码： 12345678910111213141516171819202122232425public class EscapeAnalysisTest &#123; public static void main(String[] args) &#123; long a1 = System.currentTimeMillis(); for (int i = 0; i &lt; 1000000; i++) &#123; alloc(); &#125; // 查看执行时间 long a2 = System.currentTimeMillis(); System.out.println(\"cost \" + (a2 - a1) + \" ms\"); // 为了方便查看堆内存中对象个数，线程sleep try &#123; Thread.sleep(100000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; private static void alloc() &#123; User user = new User(); &#125; static class User &#123; &#125;&#125; 其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象。 在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化。 指定以下JVM参数并运行： -Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError 在程序打印出 cost XX ms 后，代码运行结束之前，使用[jmap][1]命令，来查看下当前堆内存中有多少个User对象： 从上面的jmap执行结果中可以看到，堆中共创建了100万个StackAllocTest$User实例。 在关闭逃避分析的情况下（-XX:-DoEscapeAnalysis），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。 接下来，开启逃逸分析，再来执行下以上代码。 -Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError 在程序打印出 cost XX ms 后，代码运行结束之前，使用jmap命令，来查看下当前堆内存中有多少个User对象： 从以上打印结果中可以发现，开启了逃逸分析之后（-XX:+DoEscapeAnalysis），在堆内存中只有13万多个StackAllocTest$User对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了13万。 除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少。 总结随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。","tags":[{"name":"逃逸分析","slug":"逃逸分析","permalink":"http://liyf155.github.io/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"}]},{"title":"03-JVM内存分配策略与回收策略","date":"2020-05-14T22:36:42.000Z","path":"2020/05/15/jvm/03-JVM内存分配策略与回收策略/","text":"JVM内存分配策略与回收策略对象的内存分配，一般都是在堆上进行分配，但也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配，刚new的对象分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪种垃圾收集器组合，还有虚拟机中与内存相关参数的设置。 1. 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。先来看一个例子 123456789101112131415161718public class EdenSpaceTest &#123; private static final int _1MB = 1024 * 1024; /** * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC */ public static void testAllocation() &#123; byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; 运行结果（不同的垃圾收集器，运行的结果不一样）： [GC (Allocation Failure) [ParNew: 8001K-&gt;447K(9216K), 0.0100033 secs] 8001K-&gt;6591K(19456K), 0.0100490 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]Heap par new generation total 9216K, used 4709K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf0297a0, 0x00000007bf400000) from space 1024K, 43% used [0x00000007bf500000, 0x00000007bf56ff70, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000) Metaspace used 3251K, capacity 4496K, committed 4864K, reserved 1056768K class space used 357K, capacity 388K, committed 512K, reserved 1048576K 通过 -Xms20M -Xmx20M -Xmn10M，将堆大小设置为20M且不可扩展，Eden大小设置为10M，当程序运行时，尝试分配三个2M的对象和一个4M的对象，默认情况下，Eden与Survivor的比例是8：1，其空间大小如下图所示： 执行testAllocation()中分配allocation4对象的语句发生一次Minor GC，Eden区从8001K变为447K，而总内存占用量几乎没有减少，因为allocation1、2、3三个对象都存活着，虚拟机几乎没有找到可回收的对象，而allocation4需要4M的空间来存放，很明显Eden区已经存不下了，它已经被占用了6M，所以只好通过分配担保机制将allocation4分配到老年代。注意JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，但不同垃圾回收器组合，担保机制也略有不同。例如在Serial+Serial Old的情况下，发现放不下就直接启动担保机制；而在Parallel Scavenge+Serial Old的情况下，却是先要去判断一下要分配的内存是不是&gt;=Eden区大小的一半，如果是那么直接把该对象放入老生代，否则才会启动担保机制。 2. 大对象直接进入老年代对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。先看例子： 1234567891011121314public class BigClassTest &#123; private static final int _1MB = 1024 * 1024; /** * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:PretenureSizeThreshold=3145728 */ public static void testAllocation() &#123; byte[] allocation = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; 运行结果： Heap par new generation total 9216K, used 1855K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 22% used [0x00000007bec00000, 0x00000007bedcfeb0, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 3176K, capacity 4496K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K 从运行结果可以看到， the space 10240K, 40% used，老年代的10MB空间被使用了40%，而Eden空间几乎没有被使用，也就是说，allocation变量创建后，由于PretenureSizeThreshold参数被设置为3145728，即3MB，意思就是大于3MB的对象直接被分配到老年代，所以老年代的空间被使用了40%。 注意：PretenureSizeThreshold参数值对Serial和ParNew两个款收集器有效 3. 长期存活的对象将进入老年代虚拟机采用分代收集的思想来管理内存，那么回收内存时就必须能识别哪些对象应放在新生代，哪些对象放在老年代，所以虚拟机定义了一个年龄计数器，用来记录对象在Eden区经过Minor GC后仍然存活，且能Survivor空间能够存放得下，那么该对象就会拷贝到Survivor空间，且对象年龄设为1，没经过一次Minor GC就加1，达到默认年龄15后，就被晋升到老年代中，年龄值可以通过参数 -XX:MaxTenuringThreshold进行设置。 为什么默认年龄是15呢？是否可以设置为31？答案是否，因为虚拟机给该字段定义的是一个字节，所以其最大值也就是15。 示例： 1234567891011121314151617181920public class MaxTeuningAgeTest &#123; private static final int _1MB = 1024 * 1024; /** * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution */ public static void testAllocation() &#123; byte[] allocation1, allocation2, allocation3; allocation1 = new byte[ _1MB / 4]; allocation2 = new byte[4 * _1MB]; allocation3 = new byte[4 * _1MB]; allocation3 = null; allocation3 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; -XX:MaxTenuringThreshold=1的结果 [GC (Allocation Failure) [ParNewDesired survivor size 524288 bytes, new threshold 1 (max 1) age 1: 669064 bytes, 669064 total: 6043K-&gt;685K(9216K), 0.0033696 secs] 6043K-&gt;4781K(19456K), 0.0033882 secs] [Times: user=0.01 sys=0.00, real=0.01 secs][GC (Allocation Failure) [ParNewDesired survivor size 524288 bytes, new threshold 1 (max 1) age 1: 2504 bytes, 2504 total: 4863K-&gt;204K(9216K), 0.0008355 secs] 8959K-&gt;4967K(19456K), 0.0008523 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heappar new generation total 9216K, used 4520K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf036d40, 0x00000007bf400000)from space 1024K, 19% used [0x00000007bf400000, 0x00000007bf4332e8, 0x00000007bf500000)to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)tenured generation total 10240K, used 4762K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 46% used [0x00000007bf600000, 0x00000007bfaa6b68, 0x00000007bfaa6c00, 0x00000007c0000000)Metaspace used 3205K, capacity 4496K, committed 4864K, reserved 1056768Kclass space used 356K, capacity 388K, committed 512K, reserved 1048576K -XX:MaxTenuringThreshold=15的结果 [GC (Allocation Failure) [ParNewDesired survivor size 524288 bytes, new threshold 1 (max 15) -age 1: 693400 bytes, 693400 total6209K-&gt;703K(9216K), 0.0030625 secs] 6209K-&gt;4799K(19456K), 0.0030844 secs] [Times: user=0.01 sys=0.00, real=0.00 secs][GC (Allocation Failure) [ParNewDesired survivor size 524288 bytes, new threshold 15 (max 15)-age 1: 1232 bytes, 1232 total4883K-&gt;83K(9216K), 0.0007895 secs] 8979K-&gt;4834K(19456K), 0.0008076 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]Heap par new generation total 9216K, used 4398K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf036bb0, 0x00000007bf400000)from space 1024K, 8% used [0x00000007bf400000, 0x00000007bf414d40, 0x00000007bf500000)to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 4750K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 46% used [0x00000007bf600000, 0x00000007bfaa3b00, 0x00000007bfaa3c00, 0x00000007c0000000) Metaspace used 3252K, capacity 4496K, committed 4864K, reserved 1056768Kclass space used 357K, capacity 388K, committed 512K, reserved 1048576K 4. 动态对象年龄判定为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到MaxTenuringThreshold设置的值才能晋升到老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。","tags":[{"name":"JVM内存分配策略与回收策略","slug":"JVM内存分配策略与回收策略","permalink":"http://liyf155.github.io/tags/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"}]},{"title":"02-垃圾收集器","date":"2020-05-12T14:45:48.000Z","path":"2020/05/12/jvm/02-垃圾收集器/","text":"垃圾收集器虽然Java在实际开发中，不用像C++那样在代码中指明内存的回收，但是我们必须知晓其垃圾回收的机制以及内存分配的原理，因为当我们需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些技术实施必要的监控和调节。 垃圾收集器（Garbage Collection，GC），诞生于1960年的MIT的Lisp语言（一门真正使用内存动态分配和垃圾收集技术的语言），目前已经非常成熟。上一篇介绍了Java内存运行时区域的各个部分，其中程序计数器、Java栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每个线帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题。但Java堆和方法区则不一样，我们只有在程序处于运行期间时才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的内存就是指这两个区域。 1. 对象存活判断判断对象存活一般有两种算法 1.1 引用计数算法引用计数算法，是给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。 123456789101112131415161718192021public class ReferenceCounterTest &#123; Object instance = null; private static final int MEMORY = 1024 * 1024; // 1MB private byte[] size = new byte[2 * MEMORY]; public static void runGc() &#123; ReferenceCounterTest objA = new ReferenceCounterTest(); ReferenceCounterTest objB = new ReferenceCounterTest(); // 将两个对象互相引用进行关联 objA.instance = objB; objB.instance = objA; // 将两个对象设置为空 objA = null; objB = null; // 手动做GC处理，程序中不要这么做 System.gc(); &#125; public static void main(String[] args) &#123; runGc(); &#125; &#125; 1.2 可达性分析算法可达性分析算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如下图所示，对象obj5/6/7不能到达GC Roots点，所以该3个对象将会被回收。 在Java语言中，可作为GC Roots的对象有如下几种： 1. 虚拟机栈中引用的对象 2. 方法区中静态属性引用的对象 3. 方法区中常量引用的对象 4. 本地方法栈中JNI引用的对象2. 垃圾收集算法2.1 标记-清除算法标记-清除算法，分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后再统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 缺点 效率：标记和清除两个过程的效率都不高 空间：会产生大量不连续的内存碎片，当空间需要分配较大对象时，无法找到足够的连续内存，从而不得不提前触发另一次收集动作。 2.2 复制算法为了解决效率问题，“复制”收集算法应运而生，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当所使用的一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点 将内存缩小为原来的一半，代价太高 对象存活率较高时做复制操作（即内存较大时），效率相对较低 2.3 标记-整理算法标记-整理算法，标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。 2.4 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配，就必须采用“标记-整理”算法来进行回收。 3. 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 3.1 Serial收集器Serial收集器是最基本、发展历史最悠久的收集器，它是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，即“Stop The World”。 3.2 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio/-XX:PretenureSizeThreshold/-XX:HandlePromotionFailure等）、收集算法、Stop The World对象分配规则、回收策略等，都与Serial收集器完全一样。 3.3 Parallel Scavenger收集器Parallel Scavenger收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，其特点是它的关注点与其他收集器不同，它关注系统的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/（运行代码时间+垃圾收集时间）。 Parallel Scavenger收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的：-XX:GCTimeRatio参数。 3.4 Serial Old收集器Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要的两大用途：一是在JDK1.5以及之前的版本中与Parallel Scavenger收集器搭配使用；二是作为CMS收集器的后备预案。 3.5 Parallel Old收集器Parallel Old是Parallel Scavenger收集器的老年代版本，使用多线程和“标记-整理”算法，这个收集器是在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenger收集器一直处于比较尴尬的状态，原因是如果新生代选择了Parallel Scavenger收集器，老年代除了Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的缺项，使用了Parallel Scavenger收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合有效。 3.6 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用比较重视服务的响应速度，希望系统停顿时间最短，给用户带来良好的用户体验。 CMS收集器运作过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中初始标记、重新标记两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段较长，但比并发标记阶段要短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收是与用户贤臣个一起冰法的执行。 优点：并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 3.7 G1收集器G1收集器是目前技术发展的最前沿成果之一，Hotspot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片； 可预测停顿，降低停顿时间的同时还能简历可预测停顿时间模型，能让使用者明确指定一个长度为N毫秒的时间段内，消耗在垃圾收集器上的时间不能超过N毫秒； 使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分区域的集合。G1 收集步骤： 标记阶段：首先初始标记，这个阶段是停顿的，并且会触发一次普通Minor GC； Root Region Scanning，程序运行过程中会回收Survivor区，这一过程必须在young GC之前完成； Concurrent Marking，在整个堆中进行并发标记，此过程可能被Young GC中断。在并发标记阶段，弱发现区域对象中的所有对象都是可回收的，那这个区域会被立即回收，同时在并发标记过程中，会计算每个区域的对象存货性； Remark，再标记，会有短暂暂停。再标记阶段是用来收集并发标记阶段产生新的垃圾；G1中采用了比CMS更快的初始快照算法； Copy/Clean up，多线程清除失活对象，会有短暂停顿。G1将回收区域的存活对象拷贝到新区域，清除可回收区域，并发清空回收区域并把它返回到空闲区域链表中； 复制/清除过程后，回收区域的活性对象已经被击中回收到深蓝色和深绿色区域； 附录一：常用收集器组合 新生代GC策略 年老代GC策略 说明 Serial Serial Old 使用-XX:+UseSerialGC选项来开启，Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。 Parallel Scavenge Serial Old Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 Parallel Scavenge Parallel Old -XX:+UseParallelGC Parallel Old是Serial Old的并行版本 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC，开启 -XX:MaxGCPauseMillis =50，暂停时间目标 -XX:GCPauseIntervalMillis =200，暂停间隔目标 -XX:+G1YoungGenSize=512m 年轻代大小 -XX:SurvivorRatio=6 ，幸存区比例 附录二：垃圾收集相关常用参数 参 数 描 述 UseSerialGC -XX:+UseSerialGC，使用Serial+Serial Old的收集器组合进行内存回收，Serial和Serial Old都是单线程进行GC，GC时会暂停所有应用线程 PretenureSizeThreshold 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 MaxTenuingThreshold 晋升到老年代的对象年龄。每个对象再坚持过一次Minor GC之后，年龄就增加1，当唱过这个参数值时就进入老年代 UseAdaptiveSizePolicy 动态调整Java堆中各个区域的大小以及进入老年代的年龄 HandlePromotionFailure 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 ParallelGCThreads 设置并行GC时进行内存回收的线程数 GCTimeRatio GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 MaxGCPauseMillis 设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效 CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后出发垃圾收集，默认值68%，仅在使用CMS收集器时生效 UseCMSCompactAtFullCollection 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 CMSFullGCsBeforeCompaction 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效","tags":[{"name":"垃圾收集器","slug":"垃圾收集器","permalink":"http://liyf155.github.io/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"}]},{"title":"01-JVM内存结构","date":"2020-05-11T16:01:08.000Z","path":"2020/05/12/jvm/01-JVM内存结构/","text":"JVM内存结构Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图： 1. 程序计数器定义：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 作用：线程切换后恢复到正确的执行位置 原理：通过改变计数器的值来选取下一条执行的字节码指令 特点： 线程私有 内存空间小 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 注意：此内存区域是线程私有的区域：为了使得线程切换后恢复到正确的执行位置，每条线程都配有一个独立的程序计数器，各线程互不影响 2. Java虚拟机栈定义：Java虚拟机栈（Java Virtual Machine Stacks）是Java执行内存模型，每个方法执行时都会创建的栈帧。 作用：其主要用于存储Java方法执行时的局部变量，如编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型 抛出的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 特点： 线程私有 生命周期与线程相同 注意：此内存区域也是线程私有的区域，一个Java方法从被调用到执行完成，等于一个栈帧在虚拟机栈中的入栈到出栈，局部变量表所需内存空间在方法编译时就会分配完成，在方法运行时不会改变大小 3. 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4. Java堆定义：Java堆（Java Heap）即堆内存，是垃圾收集器管理的最大区域，很多时候也被称为“GC堆” 作用：此内存区域的唯一目的就是存放对象实例，所有对象实例以及数组都要在堆上分配。 特点：此内存区域是JVM内存中最大的，它是线程共享的一块内存区域，在虚拟机启动时创建 抛出的异常：如果堆中没有足够的内存完成对象实例的分配，并且堆无法再扩展，将会抛出OutOfMemoryError异常 注意：Java堆还可以细分为：新生代和老年代，再细致点就有Eden空间、From Survivor空间、To Survivor空间等。 5. 方法区定义：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，是堆的一个逻辑部分，也称作“非堆”区域，只是为了和Java堆区分 作用：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 抛出的异常：与Java堆类似，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 注意：该区域的内存回收，主要是针对运行时常量池和对类的卸载，它也被称为永久代，回收条件比较苛刻，很少出现垃圾回收的情况 6. 运行时常量池定义：运行时常量池是方法区的一部分 作用：主要存放类文件再编译时生成的各种字面量和符号引用 特点：运行时常量池相对于Class文件常量池的另外一个特点就是动态性，即运行时也可添加新的敞亮，如String类的intern()方法 抛出的异常：运行时常量池是方法区的一部分，自然当无法满足内存分配需求时，将抛出OutOfMemoryError异常 7. 直接内存定义：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，JDK1.4引入的NIO类中基于通道和缓冲区的I/O方式，通过使用Native函数库，直接分配内存，就是指的该区域 特点：不受堆大小的限制 应用场景：适用于频繁调用的场景 抛出的异常：这部分内存被频繁地使用，也可能导致OutOfMemoryError异常的出现 附录一：控制参数 -Xms 设置堆的最小空间大小。 -Xmx 设置堆的最大空间大小。 -XX:NewSize 设置新生代最小空间大小。 -XX:MaxNewSize 设置新生代最大空间大小。 -XX:PermSize 设置永久代最小空间大小。 -XX:MaxPermSize 设置永久代最大空间大小。 -Xss 设置每个线程的堆栈大小。","tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://liyf155.github.io/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}]},{"title":"“数组”","date":"2020-03-13T01:15:37.000Z","path":"2020/03/13/algorithm/03-数据结构与算法-数组/","text":"1. 线性表与非线性表1.1 线性表线性表：指零个或多个数据元素的有限序列，线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素外，其它数据元素都是收尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。 数组就是线性表的一种数据结构，除了数组，链表、队列、栈也是线性表结构。如图： 1.2 非线性表顾名思义，非线性表是与线性表的概念相对立，它的数据元素之间并不是简单的前后关系，比如二叉树、堆、图等，所以才叫做非线性表 2. 数组数组是一种线性表结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组的这几个限制也是其有了快速访问的特征，即我们可以根据下标随机访问数组中任一元素，当然有利就有弊，想要在数组中删除和插入数据时就变得非常低效，它必须保证连续性，从而导致要做许多的数据迁移工作。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"02-什么是算法","date":"2020-03-11T05:11:59.000Z","path":"2020/03/11/algorithm/02-数据结构与算法-什么是算法/","text":"1. 算法的定义及特性什么是算法呢？算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法具有5个基本的特性： 输入：算法具有零个或多个输入； 输出：算法至少有一个或多个输出，算法是一定需要输出的； 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成； 确定性：算法的每一步骤都具有确定的含义，不会出现二义性； 可行性：算法的每一步骤都必须是可行的，也就是说，每一步都能够通过执行有限次数完成； 2. 算法设计要求2.1 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。 算法的正确性大体分为以下四个层次： 算法程序没有语法错误； 算法程序对于合法的输入数据能够产生满足要求的输出结果； 算法程序对于非法的输入数据能够得出满足规格说明的结果； 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果； 2.2 可读性可读性：算法设计的另一目的是为了便于阅读、理解和交流。 可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。 2.3 健壮性一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 2.4 时间效率高和存储量低时间效率指的是算法的执行时间，存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。当然现实中有时难以满足时间效率高和存储量低的要求，这就看系统设计而定，所以才会出现用空间换时间的说法，或者用时间换空间。 3. 复杂度分析数据结构和算法本身解决的事“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法的一个非常重要的考量指标。那如何来衡量代码的执行效率，可以通过时间复杂度分析和空间复杂度分析来进行衡量。 为什么要进行复杂度分析？ 目前网上有很多工具统计、监控执行的代码结果就能得到执行所占用的时间多少以及内存大小，但是这种统计方法有很大的局限性： 测试结果非常依赖测试环境； 测试结果受数据规模的影响很大； 3.1 时间复杂度在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记做：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。我们称之为大O记法，一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。 3.1.1 只关注循环次数最多的代码大O复杂度表示方法只是表示一种变化趋势，通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以在分析一个算法、一段代码的复杂度的时候，也只关注循环次数最多的那一段代码就可以了。 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除这个项相乘的常数 3.1.2 常见时间复杂度分析常见的时间复杂度有以下7种： O(1): Canstant Complexity 常数复杂度 O(logn)/O(nlogn): Logarithmic Complexity 对数复杂度 O(n): Linear Complexity 线性时间复杂度 O(n²): N square Complexity 平方 O(n³): N cubic Complexity 立方 O(2ⁿ): Exponential Growth 指数 O(n!): Factorial 阶乘 3.1.2.1 常数阶 O(1)O(1)只是常量级时间复杂度的一种表示法，并不是指执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)，例如： 1234567int a = 1;int b = 2;int c = 3;int d = 4;for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"hello world\");&#125; 这段代码虽然有多行，也有循环，但循环中的i是常数100，所以它的时间复杂度还是O(1)。 3.1.2.2 对数阶 O(logn)/O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 O(log₂n)代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 2&#125; 同理，O(log₃n)的代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 3&#125; 在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log₂n) 就等于 O(log₃n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。 同样，O(nlogn) 就是指时间复杂度为O(logn)的代码循环了n遍，所以时间复杂度就是n * O(logn)，即O(nlogn)。 代码示例： 1234567int i = 1;int j = 1;for (; j &lt;= k; j++) &#123; while (i &lt;= n) &#123; i = i * 2; &#125;&#125; 3.1.2.3 线性阶 O(n)O(n) 比较好理解，也就是代码执行了n遍，如： 1234int i = 1;for (; i &lt;= n; i++) &#123; System.out.println(\"hello\");&#125; 3.1.2.4 平方阶 O(n²)代码示例： 12345for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt; n; j++) &#123; System.out.println(\"hello\"); &#125;&#125; 3.1.2.5 立方阶 O(n³)道理同O(n²)一样 3.1.2.6 指数阶 O(2ⁿ)O(2ⁿ)时间复杂度是比较慢的，例如典型的斐波拉契算法就是指数阶的表示： 123456public int fib(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; return fib(n -1) + fib(n -2);&#125; 3.2 空间复杂度时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 常见的空间复杂度就是 O(1)、O(n)、O(n2) 4. 复杂度分析的种类 最好情况时间复杂度：代码再最理想情况下执行的时间复杂度 最坏情况时间复杂度：代码再最糟糕的情况下，执行的时间复杂度 平均情况时间复杂度：加权平均值，即期望值，平均时间复杂度也可以叫做加权平均时间复杂度，或者期望时间复杂度，它只是在某些情况下才用得到 均摊时间复杂度：通过摊还分析法得到的时间复杂度，可以将其看作为一种特殊的平均时间复杂度 5. 小结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"01-什么是数据结构","date":"2020-03-11T03:21:24.000Z","path":"2020/03/11/algorithm/01-数据结构与算法-什么是数据结构/","text":"1. 数据结构1.1 数据（data）数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、浮点型、字符串等数值类型，还包括字符及声音、图像、视频等非数值类型。前者可以在计算机中直接计算，而后者（声音、图像、视频等）可以通过编码手段编程字符数据来处理。 1.2 数据元素（data element）数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 例如我们定义一个数据：人类，那么人 就是数据元素 1.3 数据项数据项：一个数据元素可以由若干个数据项组成。 例如人这个数据元素，可以有眼、鼻、耳、嘴、手、脚这些数据项，也可以有姓名、年龄、性别、出生地址、联系电话等数据项。 数据项是数据不可分割的最小单位，但在做系统设计的时候，数据元素才是数据机构中简历数据模型的关键。 1.4 数据对象（data object）数据对象：是性质相同的数据元素的集合，是数据的子集。 所谓性质相同就是指数据元素具有相同数据量和类型的数据项，例如人这个数据元素，都有姓名、生日、性别等相同的数据项。 2. 数据结构 (data structure)数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在你联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。我们可以把数据结构分为以下两种： 逻辑机构 物理结构 2.1 逻辑机构逻辑结构：是指数据对象中数据元素之间的相互关系。 逻辑结构分为以下四种： 集合结构：结构中的数据元素之间除了”同属于一个集合“的关系外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状或网状结构：结构中的数据元素存在多个对多个的关系 2.2 物理结构物理结构：是指数据的逻辑结构在计算中的存储形式。 数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。 数据元素的存储结构形式有两种： 顺序存储 链式存储 2.2.1 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 例如建立一个10个元素的整型数组时，计算机就在内存中申请一片空间，按照整型所占的位置大小乘以10，从而申请一段连续的内存空间。 2.2.2 链式存储结构链式存储结构：是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的存储位置。 3. 小结从广义上讲，数据结构就是指一组数据的存储结构。下面是引用大牛的整理的一张数据结构算法的一张脑图，先熟悉一下。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}]