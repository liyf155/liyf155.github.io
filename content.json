[{"title":"01-JVM内存结构","date":"2020-05-11T16:01:08.000Z","path":"2020/05/12/jvm/01-JVM内存结构/","text":"JVM内存结构Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图： 1. 程序计数器定义：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 作用：线程切换后恢复到正确的执行位置 原理：通过改变计数器的值来选取下一条执行的字节码指令 特点： 线程私有 内存空间小 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域 注意：此内存区域是线程私有的区域：为了使得线程切换后恢复到正确的执行位置，每条线程都配有一个独立的程序计数器，各线程互不影响 2. Java虚拟机栈定义：Java虚拟机栈（Java Virtual Machine Stacks）是Java执行内存模型，每个方法执行时都会创建的栈帧。 作用：其主要用于存储Java方法执行时的局部变量，如编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型 抛出的异常： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 特点： 线程私有 生命周期与线程相同 注意：此内存区域也是线程私有的区域，一个Java方法从被调用到执行完成，等于一个栈帧在虚拟机栈中的入栈到出栈，局部变量表所需内存空间在方法编译时就会分配完成，在方法运行时不会改变大小 3. 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 4. Java堆定义：Java堆（Java Heap）即堆内存，是垃圾收集器管理的最大区域，很多时候也被称为“GC堆” 作用：此内存区域的唯一目的就是存放对象实例，所有对象实例以及数组都要在堆上分配。 特点：此内存区域是JVM内存中最大的，它是线程共享的一块内存区域，在虚拟机启动时创建 抛出的异常：如果堆中没有足够的内存完成对象实例的分配，并且堆无法再扩展，将会抛出OutOfMemoryError异常 注意：Java堆还可以细分为：新生代和老年代，再细致点就有Eden空间、From Survivor空间、To Survivor空间等。 5. 方法区定义：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，是堆的一个逻辑部分，也称作“非堆”区域，只是为了和Java堆区分 作用：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 抛出的异常：与Java堆类似，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常 注意：该区域的内存回收，主要是针对运行时常量池和对类的卸载，它也被称为永久代，回收条件比较苛刻，很少出现垃圾回收的情况 6. 运行时常量池定义：运行时常量池是方法区的一部分 作用：主要存放类文件再编译时生成的各种字面量和符号引用 特点：运行时常量池相对于Class文件常量池的另外一个特点就是动态性，即运行时也可添加新的敞亮，如String类的intern()方法 抛出的异常：运行时常量池是方法区的一部分，自然当无法满足内存分配需求时，将抛出OutOfMemoryError异常 7. 直接内存定义：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，JDK1.4引入的NIO类中基于通道和缓冲区的I/O方式，通过使用Native函数库，直接分配内存，就是指的该区域 特点：不受堆大小的限制 应用场景：适用于频繁调用的场景 抛出的异常：这部分内存被频繁地使用，也可能导致OutOfMemoryError异常的出现 附录一：控制参数 -Xms 设置堆的最小空间大小。 -Xmx 设置堆的最大空间大小。 -XX:NewSize 设置新生代最小空间大小。 -XX:MaxNewSize 设置新生代最大空间大小。 -XX:PermSize 设置永久代最小空间大小。 -XX:MaxPermSize 设置永久代最大空间大小。 -Xss 设置每个线程的堆栈大小。","tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://liyf155.github.io/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}]},{"title":"“数组”","date":"2020-03-13T01:15:37.000Z","path":"2020/03/13/algorithm/03-数据结构与算法-数组/","text":"1. 线性表与非线性表1.1 线性表线性表：指零个或多个数据元素的有限序列，线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素外，其它数据元素都是收尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。 数组就是线性表的一种数据结构，除了数组，链表、队列、栈也是线性表结构。如图： 1.2 非线性表顾名思义，非线性表是与线性表的概念相对立，它的数据元素之间并不是简单的前后关系，比如二叉树、堆、图等，所以才叫做非线性表 2. 数组数组是一种线性表结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组的这几个限制也是其有了快速访问的特征，即我们可以根据下标随机访问数组中任一元素，当然有利就有弊，想要在数组中删除和插入数据时就变得非常低效，它必须保证连续性，从而导致要做许多的数据迁移工作。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"02-什么是算法","date":"2020-03-11T05:11:59.000Z","path":"2020/03/11/algorithm/02-数据结构与算法-什么是算法/","text":"1. 算法的定义及特性什么是算法呢？算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法具有5个基本的特性： 输入：算法具有零个或多个输入； 输出：算法至少有一个或多个输出，算法是一定需要输出的； 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成； 确定性：算法的每一步骤都具有确定的含义，不会出现二义性； 可行性：算法的每一步骤都必须是可行的，也就是说，每一步都能够通过执行有限次数完成； 2. 算法设计要求2.1 正确性正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。 算法的正确性大体分为以下四个层次： 算法程序没有语法错误； 算法程序对于合法的输入数据能够产生满足要求的输出结果； 算法程序对于非法的输入数据能够得出满足规格说明的结果； 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果； 2.2 可读性可读性：算法设计的另一目的是为了便于阅读、理解和交流。 可读性高有助于人们理解算法，晦涩难懂的算法往往隐含错误，不易被发现，并且难于调试和修改。 2.3 健壮性一个好的算法还应该能对输入数据不合法的情况做合适的处理。比如输入的时间或者距离不应该是负数等。 健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 2.4 时间效率高和存储量低时间效率指的是算法的执行时间，存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。当然现实中有时难以满足时间效率高和存储量低的要求，这就看系统设计而定，所以才会出现用空间换时间的说法，或者用时间换空间。 3. 复杂度分析数据结构和算法本身解决的事“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法的一个非常重要的考量指标。那如何来衡量代码的执行效率，可以通过时间复杂度分析和空间复杂度分析来进行衡量。 为什么要进行复杂度分析？ 目前网上有很多工具统计、监控执行的代码结果就能得到执行所占用的时间多少以及内存大小，但是这种统计方法有很大的局限性： 测试结果非常依赖测试环境； 测试结果受数据规模的影响很大； 3.1 时间复杂度在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记做：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。我们称之为大O记法，一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。 3.1.1 只关注循环次数最多的代码大O复杂度表示方法只是表示一种变化趋势，通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以在分析一个算法、一段代码的复杂度的时候，也只关注循环次数最多的那一段代码就可以了。 用常数1取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是1，则去除这个项相乘的常数 3.1.2 常见时间复杂度分析常见的时间复杂度有以下7种： O(1): Canstant Complexity 常数复杂度 O(logn)/O(nlogn): Logarithmic Complexity 对数复杂度 O(n): Linear Complexity 线性时间复杂度 O(n²): N square Complexity 平方 O(n³): N cubic Complexity 立方 O(2ⁿ): Exponential Growth 指数 O(n!): Factorial 阶乘 3.1.2.1 常数阶 O(1)O(1)只是常量级时间复杂度的一种表示法，并不是指执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)，例如： 1234567int a = 1;int b = 2;int c = 3;int d = 4;for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"hello world\");&#125; 这段代码虽然有多行，也有循环，但循环中的i是常数100，所以它的时间复杂度还是O(1)。 3.1.2.2 对数阶 O(logn)/O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 O(log₂n)代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 2&#125; 同理，O(log₃n)的代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 3&#125; 在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log₂n) 就等于 O(log₃n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。 同样，O(nlogn) 就是指时间复杂度为O(logn)的代码循环了n遍，所以时间复杂度就是n * O(logn)，即O(nlogn)。 代码示例： 1234567int i = 1;int j = 1;for (; j &lt;= k; j++) &#123; while (i &lt;= n) &#123; i = i * 2; &#125;&#125; 3.1.2.3 线性阶 O(n)O(n) 比较好理解，也就是代码执行了n遍，如： 1234int i = 1;for (; i &lt;= n; i++) &#123; System.out.println(\"hello\");&#125; 3.1.2.4 平方阶 O(n²)代码示例： 12345for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt; n; j++) &#123; System.out.println(\"hello\"); &#125;&#125; 3.1.2.5 立方阶 O(n³)道理同O(n²)一样 3.1.2.6 指数阶 O(2ⁿ)O(2ⁿ)时间复杂度是比较慢的，例如典型的斐波拉契算法就是指数阶的表示： 123456public int fib(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; return fib(n -1) + fib(n -2);&#125; 3.2 空间复杂度时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 常见的空间复杂度就是 O(1)、O(n)、O(n2) 4. 复杂度分析的种类 最好情况时间复杂度：代码再最理想情况下执行的时间复杂度 最坏情况时间复杂度：代码再最糟糕的情况下，执行的时间复杂度 平均情况时间复杂度：加权平均值，即期望值，平均时间复杂度也可以叫做加权平均时间复杂度，或者期望时间复杂度，它只是在某些情况下才用得到 均摊时间复杂度：通过摊还分析法得到的时间复杂度，可以将其看作为一种特殊的平均时间复杂度 5. 小结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"01-什么是数据结构","date":"2020-03-11T03:21:24.000Z","path":"2020/03/11/algorithm/01-数据结构与算法-什么是数据结构/","text":"1. 数据结构1.1 数据（data）数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、浮点型、字符串等数值类型，还包括字符及声音、图像、视频等非数值类型。前者可以在计算机中直接计算，而后者（声音、图像、视频等）可以通过编码手段编程字符数据来处理。 1.2 数据元素（data element）数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 例如我们定义一个数据：人类，那么人 就是数据元素 1.3 数据项数据项：一个数据元素可以由若干个数据项组成。 例如人这个数据元素，可以有眼、鼻、耳、嘴、手、脚这些数据项，也可以有姓名、年龄、性别、出生地址、联系电话等数据项。 数据项是数据不可分割的最小单位，但在做系统设计的时候，数据元素才是数据机构中简历数据模型的关键。 1.4 数据对象（data object）数据对象：是性质相同的数据元素的集合，是数据的子集。 所谓性质相同就是指数据元素具有相同数据量和类型的数据项，例如人这个数据元素，都有姓名、生日、性别等相同的数据项。 2. 数据结构 (data structure)数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。在计算机中，数据元素并不是孤立、杂乱无序的，而是具有内在你联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。我们可以把数据结构分为以下两种： 逻辑机构 物理结构 2.1 逻辑机构逻辑结构：是指数据对象中数据元素之间的相互关系。 逻辑结构分为以下四种： 集合结构：结构中的数据元素之间除了”同属于一个集合“的关系外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状或网状结构：结构中的数据元素存在多个对多个的关系 2.2 物理结构物理结构：是指数据的逻辑结构在计算中的存储形式。 数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。存储器主要是针对内存而言的，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。 数据元素的存储结构形式有两种： 顺序存储 链式存储 2.2.1 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 例如建立一个10个元素的整型数组时，计算机就在内存中申请一片空间，按照整型所占的位置大小乘以10，从而申请一段连续的内存空间。 2.2.2 链式存储结构链式存储结构：是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的存储位置。 3. 小结从广义上讲，数据结构就是指一组数据的存储结构。下面是引用大牛的整理的一张数据结构算法的一张脑图，先熟悉一下。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}]