[{"title":"02 | 垃圾收集器与内存分配策略","date":"2020-01-15T07:28:10.000Z","path":"2020/01/15/02-垃圾收集器与内存分配策略/","text":"二、垃圾收集器与内存分配策略虽然Java在实际开发中，不用像C++那样在代码中指明内存的回收，但是我们必须知晓其垃圾回收的机制以及内存分配的原理，因为当我们需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些技术实施必要的监控和调节。 垃圾收集器（Garbage Collection，GC），诞生于1960年的MIT的Lisp语言（一门真正使用内存动态分配和垃圾收集技术的语言），目前已经非常成熟。上一篇介绍了Java内存运行时区域的各个部分，其中程序计数器、Java栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每个线帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题。但Java堆和方法区则不一样，我们只有在程序处于运行期间时才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的内存就是指这两个区域。 1. 对象存活判断判断对象存活一般有两种算法 1.1 引用计数算法引用计数算法，是给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。一个简单的循环引用问题描述如下：有对象 A 和对象 B，对象 A 中含有对象 B 的引用，对象 B 中含有对象 A 的引用。此时，对象 A 和对象 B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。 123456789101112131415161718192021public class ReferenceCounterTest &#123; Object instance = null; private static final int MEMORY = 1024 * 1024; // 1MB private byte[] size = new byte[2 * MEMORY]; public static void runGc() &#123; ReferenceCounterTest objA = new ReferenceCounterTest(); ReferenceCounterTest objB = new ReferenceCounterTest(); // 将两个对象互相引用进行关联 objA.instance = objB; objB.instance = objA; // 将两个对象设置为空 objA = null; objB = null; // 手动做GC处理，程序中不要这么做 System.gc(); &#125; public static void main(String[] args) &#123; runGc(); &#125; &#125; 1.2 可达性分析算法可达性分析算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。如下图所示，对象obj5/6/7不能到达GC Roots点，所以该3个对象将会被回收。 在Java语言中，可作为GC Roots的对象有如下几种： 1. 虚拟机栈中引用的对象 2. 方法区中静态属性引用的对象 3. 方法区中常量引用的对象 4. 本地方法栈中JNI引用的对象2. 垃圾收集算法2.1 标记-清除算法标记-清除算法，分为“标记”和“清除”两个阶段：首先标记处所有需要回收的对象，在标记完成后再统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。 缺点 效率：标记和清除两个过程的效率都不高 空间：会产生大量不连续的内存碎片，当空间需要分配较大对象时，无法找到足够的连续内存，从而不得不提前触发另一次收集动作。 2.2 复制算法为了解决效率问题，“复制”收集算法应运而生，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当所使用的一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点 将内存缩小为原来的一半，代价太高 对象存活率较高时做复制操作（即内存较大时），效率相对较低 2.3 标记-整理算法标记-整理算法，标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。 2.4 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配，就必须采用“标记-整理”算法来进行回收。 3. 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 3.1 Serial收集器Serial收集器是最基本、发展历史最悠久的收集器，它是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，即“Stop The World”。 3.2 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio/-XX:PretenureSizeThreshold/-XX:HandlePromotionFailure等）、收集算法、Stop The World对象分配规则、回收策略等，都与Serial收集器完全一样。 3.3 Parallel Scavenger收集器Parallel Scavenger收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，其特点是它的关注点与其他收集器不同，它关注系统的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行代码时间/（运行代码时间+垃圾收集时间）。 Parallel Scavenger收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的：-XX:GCTimeRatio参数。 3.4 Serial Old收集器Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要的两大用途：一是在JDK1.5以及之前的版本中与Parallel Scavenger收集器搭配使用；二是作为CMS收集器的后备预案。 3.5 Parallel Old收集器Parallel Old是Parallel Scavenger收集器的老年代版本，使用多线程和“标记-整理”算法，这个收集器是在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenger收集器一直处于比较尴尬的状态，原因是如果新生代选择了Parallel Scavenger收集器，老年代除了Serial Old收集器外别无选择。由于老年代Serial Old收集器在服务端应用性能上的缺项，使用了Parallel Scavenger收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合有效。 3.6 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用比较重视服务的响应速度，希望系统停顿时间最短，给用户带来良好的用户体验。 CMS收集器运作过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中初始标记、重新标记两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段较长，但比并发标记阶段要短。由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收是与用户贤臣个一起冰法的执行。 优点：并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 3.7 G1收集器G1收集器是目前技术发展的最前沿成果之一，Hotspot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片； 可预测停顿，降低停顿时间的同时还能简历可预测停顿时间模型，能让使用者明确指定一个长度为N毫秒的时间段内，消耗在垃圾收集器上的时间不能超过N毫秒； 使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分区域的集合。G1 收集步骤： 标记阶段：首先初始标记，这个阶段是停顿的，并且会触发一次普通Minor GC； Root Region Scanning，程序运行过程中会回收Survivor区，这一过程必须在young GC之前完成； Concurrent Marking，在整个堆中进行并发标记，此过程可能被Young GC中断。在并发标记阶段，弱发现区域对象中的所有对象都是可回收的，那这个区域会被立即回收，同时在并发标记过程中，会计算每个区域的对象存货性； Remark，再标记，会有短暂暂停。再标记阶段是用来收集并发标记阶段产生新的垃圾；G1中采用了比CMS更快的初始快照算法； Copy/Clean up，多线程清除失活对象，会有短暂停顿。G1将回收区域的存活对象拷贝到新区域，清除可回收区域，并发清空回收区域并把它返回到空闲区域链表中； 复制/清除过程后，回收区域的活性对象已经被击中回收到深蓝色和深绿色区域； 附录：常用收集器组合 新生代GC策略 年老代GC策略 说明 Serial Serial Old Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程 Serial CMS+Serial Old CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。 ParNew CMS 使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。 ParNew Serial Old 使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。 Parallel Scavenge Serial Old Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。 Parallel Scavenge Parallel Old Parallel Old是Serial Old的并行版本 G1GC G1GC -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC #开启 *-XX:MaxGCPauseMillis =50 #暂停时间目标 -XX:GCPauseIntervalMillis =200 #暂停间隔目标 -XX:+G1YoungGenSize=512m #年轻代大小 -XX:SurvivorRatio=6 #幸存区比例","tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://liyf155.github.io/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}]},{"title":"01 | JVM内存结构","date":"2020-01-14T14:45:53.000Z","path":"2020/01/14/01-JVM内存结构/","text":"JVM内存结构Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。首先来看一下两张图，分别是JVM内存结构图和运行时数据区域： JVM内存结构图： JVM运行时数据区域图： 注意：以下大部分内容摘自《深入理解Java虚拟机 JVM高级特性与最佳实战》一书 程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。 Java栈：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈：本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。 方法区：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 Java堆：对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 Java堆的内存细分如下图所示： ​ 附录一：控制参数-Xms 设置堆的最小空间大小。 -Xmx 设置堆的最大空间大小。 -XX:NewSize 设置新生代最小空间大小。 -XX:MaxNewSize 设置新生代最大空间大小。 -XX:PermSize 设置永久代最小空间大小。 -XX:MaxPermSize 设置永久代最大空间大小。 -Xss 设置每个线程的堆栈大小。 附录二：对象分配规则 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC； 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象），这样做的目的是避免在Eden区和两个Survivor区之间发生的大量的内存拷贝（新生代采用复制算法收集内存）; 长期存活的对象进入老年代：虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值，对象则进入老年区； 动态判断对象的年龄，如果Survivor中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代； 空间分配担保：每次进行Minor GC时，JVM会计算Survivor区移动至老年区的对象平均大小，如果这个值大于老年区的剩余值大小，则进行一次Full GC，如果小于检查HandlePromotionFailure设置，则只进行Minor GC。","tags":[{"name":"JVM内存结构","slug":"JVM内存结构","permalink":"http://liyf155.github.io/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"}]},{"title":"01 | 复杂度分析","date":"2019-12-29T16:21:52.000Z","path":"2019/12/30/01-复杂度分析/","text":"数据结构与算法学习-复杂度分析1、什么是复杂度分析数据结构和算法本身解决的事“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法的一个非常重要的考量指标。那如何来衡量代码的执行效率，可以通过时间复杂度分析和空间复杂度分析来进行衡量。 2、 为什么要进行复杂度分析目前网上有很多工具统计、监控执行的代码结果就能得到执行所占用的时间多少以及内存大小，但是这种统计方法有很大的局限性： 测试结果非常依赖测试环境； 测试结果受数据规模的影响很大； 3、大O复杂度表示法大O时间复杂度表示法，实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫做监禁事件复杂度，简称时间复杂度。 当 n 很大时，可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。 4、时间复杂度分析4.1. 只关注循环次数最多的代码大O复杂度表示方法只是表示一种变化趋势，通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以在分析一个算法、一段代码的复杂度的时候，也只关注循环次数最多的那一段代码就可以了。 4.2. 加法法则总的时间复杂度就等于量级最大的那段代码的时间复杂度，所以这整段代码的时间复杂度是O(n²)。 4.3. 乘法法则如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)T2(n)=O(f(n))O(g(n))=O(f(n)*g(n))。也就是说，假设 T1(n) = O(n)，T2(n) = O(n2)，则 T1(n) * T2(n) = O(n3)，所以嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 5、常见时间复杂度分析常见的时间复杂度有以下7种： O(1): Canstant Complexity 常数复杂度 O(logn)/O(nlogn): Logarithmic Complexity 对数复杂度 O(n): Linear Complexity 线性时间复杂度 O(n²): N square Complexity 平方 O(n³): N cubic Complexity 立方 O(2ⁿ): Exponential Growth 指数 O(n!): Factorial 阶乘 5.1 O(1) 常数复杂度O(1)只是常量级时间复杂度的一种表示法，并不是指执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)，例如： 1234567int a = 1;int b = 2;int c = 3;int d = 4;for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"hello world\");&#125; 这段代码虽然有多行，也有循环，但循环中的i是常数100，所以它的时间复杂度还是O(1)。 5.2 O(logn)/O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。 O(log₂n)代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 2&#125; 同理，O(log₃n)的代码示例： 1234int i = 1;while (i &lt;= n) &#123; i = i * 3&#125; 在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log₂n) 就等于 O(log₃n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。 同样，O(nlogn) 就是指时间复杂度为O(logn)的代码循环了n遍，所以时间复杂度就是n * O(logn)，即O(nlogn)。 代码示例： 1234567int i = 1;int j = 1;for (; j &lt;= k; j++) &#123; while (i &lt;= n) &#123; i = i * 2; &#125;&#125; 5.3 O(n)O(n) 比较好理解，也就是代码执行了n遍，如： 1234int i = 1;for (; i &lt;= n; i++) &#123; System.out.println(\"hello\");&#125; 5.4 O(n²)代码示例： 12345for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt; n; j++) &#123; System.out.println(\"hello\"); &#125;&#125; 5.5 O(n³)道理同O(n²)一样 5.6 O(2ⁿ)O(2ⁿ)时间复杂度是比较慢的，例如典型的斐波拉契算法就是指数阶的表示： 123456public int fib(int n) &#123; if (n &lt;= 2) &#123; return n; &#125; return fib(n -1) + fib(n -2);&#125; 6、 空间复杂度时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 常见的空间复杂度就是 O(1)、O(n)、O(n2) 7、复杂度分析的种类 最好情况时间复杂度：代码再最理想情况下执行的时间复杂度 最坏情况时间复杂度：代码再最糟糕的情况下，执行的时间复杂度 平均情况时间复杂度：加权平均值，即期望值，平均时间复杂度也可以叫做加权平均时间复杂度，或者期望时间复杂度，它只是在某些情况下才用得到 均摊时间复杂度：通过摊还分析法得到的时间复杂度，可以将其看作为一种特殊的平均时间复杂度 8、小结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"00 | 什么是数据结构？什么是算法？","date":"2019-12-29T16:21:30.000Z","path":"2019/12/30/00-什么是数据结构？什么是算法？/","text":"什么是数据结构-什么是算法1.1 数据结构数据（data）是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素（data element）是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。 数据对象(data Object)是性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure)是相互之间存在一种或多种特定关系的数据元素的集合。常见的数据结构有以下几种： 集合：结构中的数据元素之间除了”同属于一个集合“的关系外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状或网状结构：结构中的数据元素存在多个对多个的关系 1.2 算法算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作；一个算法具有一下5个重要特性： 有穷性：一个算法必须总是在执行有穷步后结束，且每一步都可在有穷时间内完成 确定性：算法中每一条指令必须有确切的含义，读者丽姐时不会产生二义性 可行性：一个算法是能行的，即算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象集合 输出：一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量 1.3 小结从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。下面是引用大牛的整理的一张数据结构算法的一张脑图，先熟悉一下。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://liyf155.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}]