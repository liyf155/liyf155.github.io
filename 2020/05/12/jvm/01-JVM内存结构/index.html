<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kevin Lee's technology bolgs!"><meta name="keywords" content="Java,Algorithm,Spring,Spring Boot,Spring Cloud"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>01-JVM内存结构 | Kevin Lee's Blog</title><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">01-JVM内存结构</h1><a id="logo" href="/.">Kevin Lee's Blog</a><p class="description">You can do nothing!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">01-JVM内存结构</h1><div class="post-meta"><a href="/2020/05/12/jvm/01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#comments" class="comment-count"></a><p><span class="date">May 12, 2020</span><span><a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="category">深入理解Java虚拟机</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将包括以下几个运行时数据区域，如下图：</p>
<p><img src="/2020/05/12/jvm/01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/image-20200507230515633.png" alt="image-20200507230515633"></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p><strong>定义：</strong>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p>
<p><strong>作用：</strong>线程切换后恢复到正确的执行位置</p>
<p><strong>原理：</strong>通过改变计数器的值来选取下一条执行的字节码指令</p>
<p><strong>特点：</strong> </p>
<ul>
<li>线程私有 </li>
<li>内存空间小 </li>
<li>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</li>
</ul>
<p><strong>注意：</strong>此内存区域是线程私有的区域：为了使得线程切换后恢复到正确的执行位置，每条线程都配有一个独立的程序计数器，各线程互不影响</p>
<h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3><p><strong>定义：</strong>Java虚拟机栈（Java Virtual Machine Stacks）是Java执行内存模型，每个方法执行时都会创建的栈帧。</p>
<p><strong>作用：</strong>其主要用于存储Java方法执行时的局部变量，如编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型</p>
<p><strong>抛出的异常：</strong></p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；</li>
<li>如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</li>
</ul>
<p><strong>特点：</strong> </p>
<ul>
<li>线程私有 </li>
<li>生命周期与线程相同</li>
</ul>
<p><strong>注意：</strong>此内存区域也是线程私有的区域，一个Java方法从被调用到执行完成，等于一个栈帧在虚拟机栈中的入栈到出栈，局部变量表所需内存空间在方法编译时就会分配完成，在方法运行时不会改变大小</p>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><p><strong>定义：</strong>Java堆（Java Heap）即堆内存，是垃圾收集器管理的最大区域，很多时候也被称为“GC堆”</p>
<p><strong>作用：</strong>此内存区域的唯一目的就是存放对象实例，所有对象实例以及数组都要在堆上分配。</p>
<p><strong>特点：</strong>此内存区域是JVM内存中最大的，它是线程共享的一块内存区域，在虚拟机启动时创建</p>
<p><strong>抛出的异常：</strong>如果堆中没有足够的内存完成对象实例的分配，并且堆无法再扩展，将会抛出OutOfMemoryError异常</p>
<p><strong>注意：</strong>Java堆还可以细分为：新生代和老年代，再细致点就有Eden空间、From Survivor空间、To Survivor空间等。</p>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p><strong>定义：</strong>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，是堆的一个逻辑部分，也称作“非堆”区域，只是为了和Java堆区分</p>
<p><strong>作用：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
<p><strong>抛出的异常：</strong>与Java堆类似，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</p>
<p><strong>注意：</strong>该区域的内存回收，主要是针对运行时常量池和对类的卸载，它也被称为永久代，回收条件比较苛刻，很少出现垃圾回收的情况</p>
<h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p><strong>定义：</strong>运行时常量池是方法区的一部分</p>
<p><strong>作用：</strong>主要存放类文件再编译时生成的各种字面量和符号引用</p>
<p><strong>特点：</strong>运行时常量池相对于Class文件常量池的另外一个特点就是动态性，即运行时也可添加新的敞亮，如String类的intern()方法</p>
<p><strong>抛出的异常：</strong>运行时常量池是方法区的一部分，自然当无法满足内存分配需求时，将抛出OutOfMemoryError异常</p>
<h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><p><strong>定义：</strong>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，JDK1.4引入的NIO类中基于通道和缓冲区的I/O方式，通过使用Native函数库，直接分配内存，就是指的该区域</p>
<p><strong>特点：</strong>不受堆大小的限制</p>
<p><strong>应用场景：</strong>适用于频繁调用的场景</p>
<p><strong>抛出的异常：</strong>这部分内存被频繁地使用，也可能导致OutOfMemoryError异常的出现</p>
<h4 id="附录一：控制参数"><a href="#附录一：控制参数" class="headerlink" title="附录一：控制参数"></a>附录一：控制参数</h4><blockquote>
<p>-Xms                      设置堆的最小空间大小。</p>
<p>-Xmx                      设置堆的最大空间大小。</p>
<p>-XX:NewSize          设置新生代最小空间大小。</p>
<p>-XX:MaxNewSize   设置新生代最大空间大小。</p>
<p>-XX:PermSize         设置永久代最小空间大小。</p>
<p>-XX:MaxPermSize  设置永久代最大空间大小。</p>
<p>-Xss                        设置每个线程的堆栈大小。</p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: Kevin Lee</p><p>原文链接: <a href="http://liyf155.github.io/2020/05/12/jvm/01-JVM内存结构/">http://liyf155.github.io/2020/05/12/jvm/01-JVM内存结构/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">JVM内存结构</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/05/12/jvm/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="pre">02-垃圾收集器</a><a href="/2020/03/13/algorithm/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/" class="next">“数组”</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM内存结构"><span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-程序计数器"><span class="toc-text">1. 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java虚拟机栈"><span class="toc-text">2. Java虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-本地方法栈"><span class="toc-text">3. 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Java堆"><span class="toc-text">4. Java堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-方法区"><span class="toc-text">5. 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-运行时常量池"><span class="toc-text">6. 运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-直接内存"><span class="toc-text">7. 直接内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#附录一：控制参数"><span class="toc-text">附录一：控制参数</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">02-垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">01-JVM内存结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/algorithm/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">“数组”</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95/">02-什么是算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">01-什么是数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">数据结构与算法学习笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 15px;">JVM内存结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Kevin Lee.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>