<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kevin Lee's technology bolgs!"><meta name="keywords" content="Java,Algorithm,Spring,Spring Boot,Spring Cloud"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>03-JVM内存分配策略与回收策略 | Kevin Lee's Blog</title><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">03-JVM内存分配策略与回收策略</h1><a id="logo" href="/.">Kevin Lee's Blog</a><p class="description">You can do nothing!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">03-JVM内存分配策略与回收策略</h1><div class="post-meta"><a href="/2020/05/15/jvm/03-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/#comments" class="comment-count"></a><p><span class="date">May 15, 2020</span><span><a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="category">深入理解Java虚拟机</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="JVM内存分配策略与回收策略"><a href="#JVM内存分配策略与回收策略" class="headerlink" title="JVM内存分配策略与回收策略"></a>JVM内存分配策略与回收策略</h2><p>对象的内存分配，一般都是在堆上进行分配，但也有可能经过JIT编译后被拆散为标量类型并间接地栈上分配，刚new的对象分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪种垃圾收集器组合，还有虚拟机中与内存相关参数的设置。</p>
<h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。先来看一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdenSpaceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（不同的垃圾收集器，运行的结果不一样）：</p>
<blockquote>
<p>[GC (Allocation Failure) [ParNew: <strong>8001K-&gt;447K</strong>(9216K), 0.0100033 secs] <strong>8001K-&gt;6591K</strong>(19456K), 0.0100490 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]<br>Heap<br> par new generation   total 9216K, used 4709K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)<br>  <strong>eden space 8192K</strong>,  52% used [0x00000007bec00000, 0x00000007bf0297a0, 0x00000007bf400000)<br>  <strong>from space 1024K</strong>,  43% used [0x00000007bf500000, 0x00000007bf56ff70, 0x00000007bf600000)<br>  <strong>to   space 1024K</strong>,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)<br> tenured generation   total 10240K, used 6144K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)<br>   the space 10240K,  60% used [0x00000007bf600000, 0x00000007bfc00030, 0x00000007bfc00200, 0x00000007c0000000)<br> Metaspace       used 3251K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 357K, capacity 388K, committed 512K, reserved 1048576K</p>
</blockquote>
<p>通过 -Xms20M -Xmx20M -Xmn10M，将堆大小设置为20M且不可扩展，Eden大小设置为10M，当程序运行时，尝试分配三个2M的对象和一个4M的对象，默认情况下，Eden与Survivor的比例是8：1，其空间大小如下图所示：</p>
<p><img src="/2020/05/15/jvm/03-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/1589683344606.jpg" alt="image-20200517104233961"></p>
<p>执行testAllocation()中分配allocation4对象的语句发生一次Minor GC，Eden区从<strong>8001K变为447K</strong>，而总内存占用量几乎没有减少，因为allocation1、2、3三个对象都存活着，虚拟机几乎没有找到可回收的对象，而allocation4需要4M的空间来存放，很明显Eden区已经存不下了，它已经被占用了6M，所以只好通过分配担保机制将allocation4分配到老年代。注意JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，但不同垃圾回收器组合，担保机制也略有不同。例如在Serial+Serial Old的情况下，发现放不下就直接启动担保机制；而在Parallel Scavenge+Serial Old的情况下，却是先要去判断一下要分配的内存是不是<strong>&gt;=Eden区大小的一半</strong>，如果是那么直接把该对象放入老生代，否则才会启动担保机制。</p>
<h3 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h3><p>对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。先看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>Heap<br> par new generation   total 9216K, used 1855K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)<br>  <strong>eden space 8192K,  22% used</strong> [0x00000007bec00000, 0x00000007bedcfeb0, 0x00000007bf400000)<br>  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)<br>  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)<br> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)<br>   <strong>the space 10240K,  40% used</strong> [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)<br> Metaspace       used 3176K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 349K, capacity 388K, committed 512K, reserved 1048576K</p>
</blockquote>
<p>从运行结果可以看到，</p>
<p><strong>the space 10240K,  40% used</strong>，老年代的10MB空间被使用了40%，而Eden空间几乎没有被使用，也就是说，allocation变量创建后，由于PretenureSizeThreshold参数被设置为3145728，即3MB，意思就是大于3MB的对象直接被分配到老年代，所以老年代的空间被使用了40%。</p>
<p><strong>注意</strong>：PretenureSizeThreshold参数值对Serial和ParNew两个款收集器有效</p>
<h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><p>虚拟机采用分代收集的思想来管理内存，那么回收内存时就必须能识别哪些对象应放在新生代，哪些对象放在老年代，所以虚拟机定义了一个年龄计数器，用来记录对象在Eden区经过Minor GC后仍然存活，且能Survivor空间能够存放得下，那么该对象就会拷贝到Survivor空间，且对象年龄设为1，没经过一次Minor GC就加1，达到默认年龄15后，就被晋升到老年代中，年龄值可以通过参数 -XX:MaxTenuringThreshold进行设置。</p>
<p>为什么默认年龄是15呢？是否可以设置为31？答案是否，因为虚拟机给该字段定义的是一个字节，所以其最大值也就是15。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTeuningAgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintCommandLineFlags -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[ _1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>-XX:MaxTenuringThreshold=1的结果</p>
<blockquote>
<p>[GC (Allocation Failure) [ParNew<br>Desired survivor size 524288 bytes, new threshold 1 (max 1)</p>
<ul>
<li>age   1:     669064 bytes,     669064 total<br>: 6043K-&gt;685K(9216K), 0.0033696 secs] 6043K-&gt;4781K(19456K), 0.0033882 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]<br>[GC (Allocation Failure) [ParNew<br>Desired survivor size 524288 bytes, new threshold 1 (max 1)</li>
<li>age   1:       2504 bytes,       2504 total<br>: 4863K-&gt;204K(9216K), 0.0008355 secs] 8959K-&gt;4967K(19456K), 0.0008523 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br>par new generation   total 9216K, used 4520K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)<br>eden space 8192K,  52% used [0x00000007bec00000, 0x00000007bf036d40, 0x00000007bf400000)<br>from space 1024K,  19% used [0x00000007bf400000, 0x00000007bf4332e8, 0x00000007bf500000)<br>to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)<br>tenured generation   total 10240K, used 4762K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)<br> the space 10240K,  46% used [0x00000007bf600000, 0x00000007bfaa6b68, 0x00000007bfaa6c00, 0x00000007c0000000)<br>Metaspace       used 3205K, capacity 4496K, committed 4864K, reserved 1056768K<br>class space    used 356K, capacity 388K, committed 512K, reserved 1048576K</li>
</ul>
</blockquote>
<p>-XX:MaxTenuringThreshold=15的结果</p>
<blockquote>
<p>[GC (Allocation Failure) [ParNew<br>Desired survivor size 524288 bytes, new threshold 1 (max 15)</p>
<dl><dt>-age   1:     693400 bytes,     693400 total</dt><dd>6209K-&gt;703K(9216K), 0.0030625 secs] 6209K-&gt;4799K(19456K), 0.0030844 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]<br>[GC (Allocation Failure) [ParNew<br>Desired survivor size 524288 bytes, new threshold 15 (max 15)</dd></dl><dl><dt>-age   1:       1232 bytes,       1232 total</dt><dd>4883K-&gt;83K(9216K), 0.0007895 secs] 8979K-&gt;4834K(19456K), 0.0008076 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]<br>Heap<br> par new generation   total 9216K, used 4398K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)<br>eden space 8192K,  52% used [0x00000007bec00000, 0x00000007bf036bb0, 0x00000007bf400000)<br>from space 1024K,   8% used [0x00000007bf400000, 0x00000007bf414d40, 0x00000007bf500000)<br>to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)<br> tenured generation   total 10240K, used 4750K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)<br> the space 10240K,  46% used [0x00000007bf600000, 0x00000007bfaa3b00, 0x00000007bfaa3c00, 0x00000007c0000000)<br> Metaspace       used 3252K, capacity 4496K, committed 4864K, reserved 1056768K<br>class space    used 357K, capacity 388K, committed 512K, reserved 1048576K</dd></dl></blockquote>
<h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到<strong>MaxTenuringThreshold</strong>设置的值才能晋升到老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<strong>MaxTenuringThreshold</strong>中要求的年龄。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Kevin Lee</p><p>原文链接: <a href="http://liyf155.github.io/2020/05/15/jvm/03-JVM内存分配策略与回收策略/">http://liyf155.github.io/2020/05/15/jvm/03-JVM内存分配策略与回收策略/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">JVM内存结构</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/05/12/jvm/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="next">02-垃圾收集器</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM内存分配策略与回收策略"><span class="toc-text">JVM内存分配策略与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-对象优先在Eden分配"><span class="toc-text">1. 对象优先在Eden分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-大对象直接进入老年代"><span class="toc-text">2. 大对象直接进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-长期存活的对象将进入老年代"><span class="toc-text">3. 长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-动态对象年龄判定"><span class="toc-text">4. 动态对象年龄判定</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/15/jvm/03-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">03-JVM内存分配策略与回收策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">02-垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">01-JVM内存结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/algorithm/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">“数组”</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95/">02-什么是算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">01-什么是数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">数据结构与算法学习笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 15px;">JVM内存结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Kevin Lee.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>