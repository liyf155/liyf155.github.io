<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Kevin Lee's technology bolgs!"><meta name="keywords" content="Java,Algorithm,Spring,Spring Boot,Spring Cloud"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>06-Java类加载器 | Kevin Lee's Blog</title><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">06-Java类加载器</h1><a id="logo" href="/.">Kevin Lee's Blog</a><p class="description">You can do nothing!</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">06-Java类加载器</h1><div class="post-meta"><a href="/2020/05/28/jvm/06-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#comments" class="comment-count"></a><p><span class="date">May 28, 2020</span><span><a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="category">深入理解Java虚拟机</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h2><p>当JVM（Java虚拟机）启动时，会形成由三个类加载器组成的初始类加载器层次结构：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzEyMTEyODU0NzI0?x-oss-process=image/format,png" alt="这里写图片描述"></p>
<h3 id="Bootstrap-classloader-－引导（也称为原始）类加载器"><a href="#Bootstrap-classloader-－引导（也称为原始）类加载器" class="headerlink" title="Bootstrap classloader －引导（也称为原始）类加载器"></a><strong>Bootstrap classloader －引导（也称为原始）类加载器</strong></h3><p>引导类加载器主要负责加载Java的核心类。在Sun的JVM中，在执行java的命令中使用-Xbootclasspath选项或使用 -D选项指定sun.boot.class.path系统属性值可以指定附加的类。这个加载器的是非常特殊的，它实际上不是 java.lang.ClassLoader的子类，而是由JVM自身实现的。我们可以通过执行以下代码来获得bootstrap classloader加载了那些核心类库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URL[] urls=sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">  System.out.println(urls[i].toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的计算机上的结果为：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">resources</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">rt</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">sunrsasign</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jsse</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jce</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">charsets</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">jfr</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/classes</span><br></pre></td></tr></table></figure>
<p>这时大家知道了为什么我们不需要在系统属性CLASSPATH中指定这些类库了吧，因为JVM在启动的时候就自动加载它们了。</p>
<h3 id="Extension-classloader-－扩展类加载器"><a href="#Extension-classloader-－扩展类加载器" class="headerlink" title="Extension classloader －扩展类加载器"></a><strong>Extension classloader －扩展类加载器</strong></h3><p>扩展类加载器负责加载JRE的扩展目录（JAVA_HOME/jre/lib/ext或者由java.ext.dirs系统属性指定的）中JAR的类包。这为引入除Java核心类以外的新功能提供了一个标准机制。因为默认的扩展目录对所有从同一个JRE中启动的JVM都是通用的，所以放入这个目录的 JAR类包对所有的JVM和system classloader都是可见的。在这个实例上调用方法getParent()总是返回空值null，因为引导加载器bootstrap classloader不是一个真正的ClassLoader实例。所以当大家执行以下代码时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">ClassLoader extensionClassloader=ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">   System.out.println(<span class="string">"the parent of extension classloader : "</span>+extensionClassloader.getParent());</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">file:</span>/Library/Java/JavaVirtualMachines/jdk1.<span class="number">7.0_79</span>.jdk/Contents/Home/jre/<span class="class"><span class="keyword">lib</span>/<span class="title">ext</span> <span class="title">the</span> <span class="title">parent</span> <span class="title">of</span> <span class="title">extension</span> <span class="title">classloader</span> : <span class="title">null</span></span></span><br></pre></td></tr></table></figure>

<p>扩展类加载器是system classloader的parent，而引导类加载器是扩展类加载器的parent，但它不是一个实际的classloader，所以为null。</p>
<h3 id="Application-classloader-－应用类加载器"><a href="#Application-classloader-－应用类加载器" class="headerlink" title="Application classloader －应用类加载器"></a><strong>Application classloader －应用类加载器</strong></h3><p>应用类加载器负责在JVM被启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH*作系统属性所指定的JAR类包和类路径。总能通过静态方法ClassLoader.getSystemClassLoader()找到该类加载器。如果没有特别指定，则用户自定义的任何类加载器都将该类加载器作为它的父加载器。执行以下代码即可获得：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>get<span class="constructor">Property(<span class="string">"java.class.path"</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果则为用户在系统属性里面设置的CLASSPATH。应用类加载器用的是全盘负责委托机制，所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入；委托机制则是先让parent（父）类加载器 (而不是super，它与parent classloader类不是继承关系)寻找，只有在parent找不到的时候才从自己的类路径中去寻找。此外类加载还采用了cache机制，也就是如果 cache中保存了这个Class就直接返回它，如果没有才从文件中读取和转换成Class，并存入cache，这就是为什么我们修改了Class但是必须重新启动JVM才能生效的原因。</p>
<p>每个ClassLoader加载Class的过程是：</p>
<blockquote>
<ol>
<li>检测此Class是否载入过（即在cache中是否有此Class），如果有到8,如果没有到2</li>
<li>如果parent classloader不存在（没有parent，那parent一定是bootstrap classloader了），到4</li>
<li>请求parent classloader载入，如果成功到8，不成功到5</li>
<li>请求jvm从bootstrap classloader中载入，如果成功到8</li>
<li>寻找Class文件（从与此classloader相关的类路径中寻找）。如果找不到则到7.</li>
<li>从文件中载入Class，到8.</li>
<li>抛出ClassNotFoundException.</li>
<li>返回Class.</li>
</ol>
</blockquote>
<p>其中5、6步我们可以通过覆盖ClassLoader的findClass方法来实现自己的载入策略。甚至覆盖loadClass方法来实现自己的载入过程。</p>
<p>类加载器的顺序是：<br>先是Bootstrap classloader，然后是Extension classloader，最后才是Application classloader。大家会发现加载的Class越是重要的越在靠前面。这样做的原因是出于安全性的考虑，试想如果Application classloader“亲自”加载了一个具有破坏性的“java.lang.System”类的后果吧。这种委托机制保证了用户即使具有一个这样的类，也把它加入到了类路径中，但是它永远不会被载入，因为这个类总是由bootstrap classloader来加载的。大家可以执行一下以下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br></pre></td></tr></table></figure>
<p>将会看到结果是null，这就表明java.lang.System是由bootstrap classloader加载的，因为bootstrap classloader不是一个真正的ClassLoader实例，而是由JVM实现的，正如前面已经说过的。</p>
<p>下面就让我们来看看JVM是如何来为我们来建立类加载器的结构的：<br>sun.misc.Launcher，顾名思义，当你执行java命令的时候，JVM会先使用bootstrap classloader载入并初始化一个Launcher，执行下来代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"the Launcher's classloader is "</span>+sun.misc.Launcher.getLauncher().getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p>结果为：<br>  the Launcher’s classloader is null (因为是用bootstrap classloader加载,所以class loader为null)，Launcher 会根据系统和命令设定初始化好class loader结构，JVM就用它来获得extension classloader和system classloader,并载入所有的需要载入的Class，最后执行java命令指定的带有静态的main方法的Class，extension classloader实际上是sun.misc.Launcher.ExtClassLoader类的一个实例，systemclassloader实际上是sun.misc.LauncherExtClassLoader类的一个实例，并且都是 java.net.URLClassLoader的子类。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Kevin Lee</p><p>原文链接: <a href="http://liyf155.github.io/2020/05/28/jvm/06-Java类加载器/">http://liyf155.github.io/2020/05/28/jvm/06-Java类加载器/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">Java类加载器</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/05/28/jvm/05-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="next">05-Java类加载过程</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java类加载器"><span class="toc-text">Java类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bootstrap-classloader-－引导（也称为原始）类加载器"><span class="toc-text">Bootstrap classloader －引导（也称为原始）类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extension-classloader-－扩展类加载器"><span class="toc-text">Extension classloader －扩展类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Application-classloader-－应用类加载器"><span class="toc-text">Application classloader －应用类加载器</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/jvm/06-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">06-Java类加载器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/jvm/05-Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">05-Java类加载过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/19/jvm/04-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">04-JVM内存分配策略-逃逸分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/15/jvm/03-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">03-JVM内存分配策略与回收策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">02-垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/12/jvm/01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">01-JVM内存结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/algorithm/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84/">“数组”</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95/">02-什么是算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/algorithm/01-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">01-什么是数据结构</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">数据结构与算法学习笔记</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解Java虚拟机</a><span class="category-list-count">6</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/" style="font-size: 15px;">JVM内存结构</a> <a href="/tags/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/" style="font-size: 15px;">JVM内存分配策略与回收策略</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 15px;">垃圾收集器</a> <a href="/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/" style="font-size: 15px;">逃逸分析</a> <a href="/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" style="font-size: 15px;">Java类加载过程</a> <a href="/tags/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" style="font-size: 15px;">Java类加载器</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">9</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Kevin Lee.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>